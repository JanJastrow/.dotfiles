#--------------------------------
# filename:     /zsh/scripts
#--------------------------------

# Search for string in all files in pwd
function f() {
    grep -rnw ./ -e "$1"
}

# mkdir and cd
function mkcd() {
    mkdir -p "$@" && cd "$_" || exit;
}

# "Fake" sha256sum
if [[ ! -x $(which sha256sum) ]]; then
    function sha256sum() {
        shasum -a256 "$1"
    }
fi

# Tar.gz with GZIP or PIGZ
function targz() {
    if [ -z "$1" ]; then
        echo "usage: targz filename.tar.gz directory"
        return
    fi
    if [[ ! -x $(which pigz) ]]; then
        tar -czf "$1" "$2"
	echo "gzip"
    else
        tar -c "$2" | pigz > "$1"
	echo "pigz"
    fi
}

# Export manpage as PDF
function manp() {
    man -t $1 | pstopdf -o $TMPDIR/$1.pdf && open $TMPDIR/$1.pdf && sleep 1 && rm $TMPDIR/$1.pdf 
}

# Convert VOB-Subs to SRT
# via ChatGPT https://chatgpt.com/share/683d6830-de78-8004-b86e-380a15a92523
sub_ocr() {
  local idx_file base lang out

  for idx_file in *.idx; do
    base="${idx_file:r}"

    lang="deu"
    out=""

    case "$base" in
      *-eng-forced | *-forced-eng)
        lang="eng"
        out="eng.forced.srt"
        ;;
      *-eng)
        lang="eng"
        out="eng.srt"
        ;;
      *-deu-forced | *-forced-deu | *-ger-forced)
        lang="deu"
        out="deu.forced.srt"
        ;;
      *-deu | *-ger)
        lang="deu"
        out="deu.srt"
        ;;
      *-forced)
        lang="deu"
        out="deu.forced.srt"
        ;;
      *)
        lang="deu"
        out="deu.srt"
        ;;
    esac

    echo "Konvertiere: $idx_file → $out (Sprache: $lang)"
    vobsubocr -l "$lang" -o "$out" "$idx_file"
  done
}

# cleanup SRT
sub_cleanup() {
  local file

  for file in *.srt; do
    echo "Bearbeite: $file"
    # Temporäre Datei zur sicheren Bearbeitung
    local tmpfile="${file}.tmp"

    # Ersetzungen:
    # 1. ... → …
    # 2. | → I
    # 3. UÜ → Ü
    sed 's/\.\.\./…/g; s/|/I/g;' "$file" > "$tmpfile" && mv "$tmpfile" "$file"
  done
}

# Clean MP3 metadata
mp3_cleanup_metadata() {
  # nullglob lokal setzen damit kein literal "*.mp3" iteriert wird, falls keine Dateien da sind
  setopt localoptions nullglob 2>/dev/null || true

  local f tmp
  local files=( *.mp3 )

  if (( ${#files[@]} == 0 )); then
    echo "Keine .mp3 Dateien im aktuellen Verzeichnis." >&2
    return 0
  fi

  for f in "${files[@]}"; do
    [[ -f "$f" ]] || continue
    tmp="${f}.tmp.mp3"   # wichtige Änderung: Ausgabe hat eine .mp3 Endung

    # -y überschreibt tmp falls schon vorhanden; -map_metadata 0 behält andere Metadaten bei
    if ffmpeg -hide_banner -loglevel error -y -i "$f" -map_metadata 0 -metadata n= -metadata TSRC= -c copy "$tmp"; then
      mv -f -- "$tmp" "$f"
      echo "Bereinigt: $f"
    else
      rm -f -- "$tmp"
      echo "Fehler beim Bearbeiten: $f" >&2
    fi
  done
}
# Send pushover notification (if set)
if [[ -z "$pushover_token" ]]; then
    function pushover() {
        curl -s \
        --form-string "token=$pushover_token" \
        --form-string "user=$pushover_user" \
        --form-string "title=$HOST" \
        --form-string "message=$1" \
        https://api.pushover.net/1/messages.json
    }
fi

# png to jpeg 95
function png2jpeg() {
        findpath=$1
        : "${findpath:="."}"
        find "$findpath" -name '*.png' | while read -r f ; do
            dir=$(dirname "$f");
            file=$(basename "$f");
            name="${file%.*}";
		magick "$f" pnm:- | cjpeg -progressive -optimize -quality 95 > "$dir/$name.jpg" </dev/null
	rm -f "$f";
    done
}

function jpeg1024() {
    magick "$1" -resize '1024x1024\>' -background black -flatten TGA:- | cjpeg -targo -optimize -progressive -quality 90 -outfile "$1".jpg
}

# Make PDFs look like scanned
# src: https://gist.github.com/andyrbell/25c8632e15d17c83a54602f6acde2724?permalink_comment_id=3295405#gistcomment-3295405
function pdf-like-scanned () {
        OUT=$(basename "$1" .pdf)
        convert -density 150 "$1" -rotate "$([ $((RANDOM % 2)) -eq 1 ] && echo -)0.$(($RANDOM % 4 + 5))" \
                -attenuate 0.4 +noise Multiplicative -attenuate 0.03 +noise Multiplicative -sharpen 0x1.0 \
                -colorspace Gray "$OUT"_scanned.pdf
}

# Extract files
# src: https://github.com/mawalu/dotfiles/blob/master/zsh/.zsh/functions.zsh#L21
function extract () {
    if [ -f "$1" ] ; then
        case $1 in
            *.tar.bz2) tar xjf "$1" ;;
            *.tar.gz) tar xzf "$1" ;;
            *.tar.zstd) tar --zstd -xf "$1" ;;
            *.bz2) bunzip2 "$1" ;;
            *.rar) unrar x "$1" ;;
            *.gz) gunzip "$1" ;;
            *.tar) tar xf "$1" ;;
            *.tbz2) tar xjf "$1" ;;
            *.tbz) tar xjf "$1" ;;
            *.tgz) tar xzf "$1" ;;
            *.zip) unzip "$1" ;;
            *.Z) uncompress "$1" ;;
            *.7z) 7z x "$1" ;;
            *) echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi  
}

# Download provided url to $HOME/Downloads
function dl() {
    if [ -z "$1" ]; then
        echo "usage: dl url --- downloads to $HOME/Downloads"
        return
    fi
    if [[ -x $(which aria2c) ]]; then
        aria2c --dir="$HOME/Downloads" --continue=true --max-connection-per-server=4 "$1"
    else
        (cd "$HOME/Downloads" && curl -O "$1")
    fi
}

# Monitor IP/Host and report with Pushover
pnotify-online() {
    local ip_address="$1"
	echo "Monitoring $ip_address …"

    while true; do
        if ping -c 1 -W 1 "$ip_address" >/dev/null; then
            echo -e "\07*Ding*"
			echo "$1 is online now."
            pushover "$1 is online now."
            break
        fi
    done
}

pnotify-offline() {
    local ip_address="$1"
    echo "Monitoring $ip_address …"
    
    while true; do
        if ! ping -c 1 -W 1 "$ip_address" >/dev/null; then
            echo -e "\07*Ding*"
			echo "$1 is offline now."
            pushover "$1 is offline now."
            break
        fi
    done
}
